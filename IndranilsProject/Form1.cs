using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using Linnarsson.Dna;
using Linnarsson.Utilities;
using System.IO;

 
namespace IndranilsProject
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void TmCalculation_Click(object sender, EventArgs e)
        {
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Title = "Select a txt file with targets";
            if (ofd.ShowDialog() != DialogResult.OK) return;

            var output = (Path.Combine(Path.GetDirectoryName(ofd.FileName), Path.GetFileNameWithoutExtension(ofd.FileName) + "_selector.txt")).OpenWrite();

            
            string[] lines = System.IO.File.ReadAllLines(ofd.FileName);
            output.WriteLine("Left Arm" + "\t" + "LA_Tm" + "\t" + "Right Arm" + "\t" + "RA_Tm" + "\t" + "Sequence" + "\t" + "Seq length" + "\t" + "%GC" + "\t" + "G/C/A/T Length" + "\t" + "leftDistance" + "\t" + "rightDistance" + "\t" + "PolyType" + "\t" + "Chromosome Name" + "\t" + "Start Position in Chr");   
            for (int i = 1; i<lines.Length; i++)// used i=1 to ignore the first line 
                {
                    string oneLine = lines[i];
                    string[] lineItems= oneLine.Split('\t');
                    string selectorFragment = lineItems[0];
                    // code for left selector arm*****************************************
                    DnaSequence sf = new DnaSequence(selectorFragment);
                    TmCalculator tm = new TmCalculator();
                    int lss = 0;
                    int len = 15;
                    DnaSequence ds=sf.SubSequence(lss, len);
                    //MessageBox.Show(ds.ToString()); 
                    double temp = tm.GetTm(ds, 0.00000005, 0.00000005, 0.05);
                    while(temp < 50)
                    {
                        
                        len++;
                        if (len == 25) break;
                        ds = sf.SubSequence(lss, len);
                        temp = tm.GetTm(ds, 0.00000005, 0.00000005, 0.05);
                        //MessageBox.Show(temp.ToString());
                        
                        
                    }
                    
                    //code for right selector arm ******************************************
                    int seqLen = (int)sf.Count;
                    len = 15;
                    DnaSequence dsR = sf.SubSequence(seqLen - len, len);
                    double temp2 = tm.GetTm(dsR, 0.00000005, 0.00000005, 0.05);
                    while (temp2 < 50)
                    {
                        len++;
                        if (len == 25) break;
                        dsR = sf.SubSequence(seqLen - len, len);
                        temp2 = tm.GetTm(dsR, 0.00000005, 0.00000005, 0.05);
                        
                    }
                    output.WriteLine(ds.ToString() + "\t" + temp.ToString() + "\t" + dsR.ToString() + "\t" + temp2.ToString() + "\t" + lineItems[0] + "\t" + lineItems[1] + "\t" + lineItems[2] + "\t" + lineItems[3] + "\t" + lineItems[4] + "\t" + lineItems[5] + "\t" + lineItems[6] + "\t" + lineItems[7] + "\t" + lineItems[8]);  
                 
                    //}
                          
                }
            MessageBox.Show("End of the run!! The location and the name of your output file is:" + Path.Combine(Path.GetDirectoryName(ofd.FileName), Path.GetFileNameWithoutExtension(ofd.FileName) + "_selector.txt"));
            output.Close(); 
            
              
            
  
        }

        private void UnSelector_Click(object sender, EventArgs e)
        {
            MessageBox.Show("This will generate 2 files: one with unique selectors and another with selectors having one or more repeats. It may take several minutes (hours!!) to generate the outputs."); 
            MessageBox.Show("Select the RMSK files ");
            OpenFileDialog ofd1 = new OpenFileDialog();
            ofd1.Multiselect = true;
            if (ofd1.ShowDialog() != DialogResult.OK) return;
            MessageBox.Show("Select the file which you have generated by Tm calculation.");
            OpenFileDialog ofd2 = new OpenFileDialog();
            if (ofd2.ShowDialog() != DialogResult.OK) return;
            var output = (Path.Combine(Path.GetDirectoryName(ofd2.FileName), Path.GetFileNameWithoutExtension(ofd2.FileName) + "_NonUniqueSelectors.txt")).OpenWrite();
            
            string[] lines = System.IO.File.ReadAllLines(ofd2.FileName);
            output.WriteLine("selectorSeq" + "\t" + "selectorLen" + "\t" + "SelectorChr" +"\t" + "selectorStart" + "\t" + "selectorEnd" + "\t" + "rmskLen" + "\t" + "rmskStart" + "\t" + "rmskEnd" +"\t"+ "rmskChr" +"\t"+ "rmskRepName");
            //output2.WriteLine("selectorSeq" + "\t" + "selectorLen" + "\t" + "SelectorChr" + "\t" + "selectorStart" + "\t" + "selectorEnd" + "\t" +  "Left Arm" + "\t" + "LA_Tm " + "\t" + "Right Arm " + "\t" + "RA_Tm " + "\t" + "%GC" + "\t" + "G/C/A/T Len" + "\t" + "Left Dis." + "\t" + "Right Dis." + "\t" + "Poly Type");
            for (int i = 1; i < lines.Length; i++)// used i=1 to ignore the first line 
            {
                string oneLine = lines[i];
                string[] lineItems = oneLine.Split('\t');
                int selectorLarmLen=lineItems [0].Length ;
                int selectorRarmLen = lineItems[2].Length;
                string selectorSeq = lineItems[4];
                int selectorLen = Convert.ToInt32(lineItems[5]);
                string selectorChr = lineItems[11]; 
                int selectorStart= Convert.ToInt32(lineItems[12]);
                int selectorEnd=selectorStart +selectorLen ;
               // MessageBox.Show(selectorSeq + " " + selectorLen + " " + selectorStart); break; 
             
                foreach (string fname in ofd1.FileNames)
                {
                    string RMSKfilename = Path.GetFileNameWithoutExtension(ofd1.FileName);
                    string[] RMSKname =RMSKfilename.Split('_');
                    if (RMSKname[0] != lineItems[11])
                    {
                        //MessageBox.Show(RMSKname[0] + " " + lineItems[11]);  
                        goto NextSelector;
 
                    } 
                    string[] rmskLines = System.IO.File.ReadAllLines(fname);
                    //int rmskCount = 0;

                    for (int j = 0; j < rmskLines.Length; j++) 
                    {
                        string rmskOneline = rmskLines[j];
                        string[] rmskLineItems = rmskOneline.Split('\t');
                        string rmskChr = rmskLineItems[5];
                        int rmskStart=Convert.ToInt32(rmskLineItems[6]);  
                        int rmskEnd=Convert.ToInt32(rmskLineItems[7]);
                        string rmskRepName = rmskLineItems[10]; 
                        int rmskLen = rmskEnd - rmskStart;
                        //MessageBox.Show(rmskChr + " " + rmskStart + " " + rmskEnd + " " + rmskLen ); 
                        
                        if (selectorChr == rmskChr && selectorLen >=rmskLen )
                        {
                            
                            if (rmskStart < selectorStart && rmskEnd < selectorStart) goto OutSide;
                            if (rmskStart > selectorEnd) goto OutSide;
                            
                            if (rmskStart < selectorStart && rmskEnd < selectorEnd )
                            {
                                if ((rmskLen / 5) <= (rmskEnd - selectorStart))
                                {
                                    output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                    goto NextSelector;
                                }
                                
                            }
                            else if (rmskStart > selectorStart && rmskEnd > selectorEnd)
                            {
                                if ((rmskLen / 5) <= (selectorEnd - rmskStart))
                                {
                                    output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                    goto NextSelector;
                                }
                                
                            }
                            else if (rmskStart >= selectorStart && rmskEnd <= selectorEnd)
                            {
                                if (((selectorStart + selectorLarmLen) < rmskStart) && ((selectorEnd - selectorRarmLen) > rmskEnd))
                                {
                                   
                                }
                                else
                                {
                                    output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                    goto NextSelector;
                                }
                            }
                            
                        }
                        else if (selectorChr == rmskChr && selectorLen < rmskLen)
                        {
                            if (selectorStart < rmskStart && selectorEnd < rmskStart) goto OutSide;
                            if (selectorStart > rmskEnd) goto OutSide;
                            if (selectorStart < rmskStart && selectorEnd < rmskEnd)
                            {
                                if ((rmskLen / 5) <= (selectorEnd - rmskStart))
                                {
                                    output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                    goto NextSelector;
                                }
                                
                            }
                            else if(selectorStart >rmskStart && selectorEnd >rmskEnd )
                            {
                                if ((rmskLen / 5) <= (rmskEnd - selectorStart))
                                {
                                    output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                    goto NextSelector;
                                }
                                
                            }
                            else if (selectorStart >= rmskStart && selectorEnd <= rmskEnd)
                            {
                                output.WriteLine(selectorSeq + "\t" + selectorLen + "\t" + selectorChr + "\t" + selectorStart + "\t" + selectorEnd + "\t" + rmskLen + "\t" + rmskStart + "\t" + rmskEnd + "\t" + rmskChr + "\t" + rmskRepName);
                                goto NextSelector;
                            }

 
                        }
                    OutSide: ;
                          
                    }
 
                }
            NextSelector: ;
            }
             
            output.Close();
            
            // code for selecting unique selectors which are not present in the file NonUniqueSelectors.txt file and writing i´n a file called _UniqueSelectors.txt


            string[] NUSLines = System.IO.File.ReadAllLines(Path.GetDirectoryName(ofd2.FileName) + "\\" + Path.GetFileNameWithoutExtension(ofd2.FileName) + "_NonUniqueSelectors.txt");
            var output2 = (Path.Combine(Path.GetDirectoryName(ofd2.FileName), Path.GetFileNameWithoutExtension(ofd2.FileName) + "_UniqueSelectors.txt")).OpenWrite();
            output2.WriteLine("selectorSeq" + "\t" + "selectorLen" + "\t" + "SelectorChr" + "\t" + "selectorStart" + "\t" +  "Left Arm" + "\t" + "LA_Tm " + "\t" + "Right Arm " + "\t" + "RA_Tm " + "\t" + "%GC" + "\t" + "G/C/A/T Len" + "\t" + "Left Dis." + "\t" + "Right Dis." + "\t" + "Poly Type");
            int flag = 0; // if seq match then flag=1 else flag=0;
            for (int k = 1; k < lines.Length; k++)// used i=1 to ignore the first line 
            {
                string oneLine = lines[k];
                string[] lineItems = oneLine.Split('\t');
                string selectorSeq = lineItems[4];
                for (int l = 1; l < NUSLines.Length; l++)
                {
                    string NUSOneline = NUSLines[l];
                    string[] NUSLineItems = NUSOneline.Split('\t');
                    string NUSSeq = NUSLineItems[0];
                    if (selectorSeq == NUSSeq)
                    {
                        flag = 1;
                       goto NextSelectorItem;
                    }
 
                }
                if (flag != 1)
                {
                    output2.WriteLine(selectorSeq + "\t" + lineItems[5]  + "\t" + lineItems[11]  + "\t" + lineItems [12] + "\t"  + lineItems[0] + "\t" + lineItems[1] + "\t" + lineItems[2] + "\t" + lineItems[3] + "\t" + lineItems[6] + "\t" + lineItems[7] + "\t" + lineItems[8] + "\t" + lineItems[9] + "\t" + lineItems[10]);
                }
            NextSelectorItem: flag=0;
            }
            output2.Close();
            MessageBox.Show("Programme executed successfully. Name of the unique and nonunique selector files are: " + Path.GetFileNameWithoutExtension(ofd2.FileName) + "_UniqueSelectors.txt  and  "+ Path.GetFileNameWithoutExtension(ofd2.FileName) + "_NonUniqueSelectors.txt");


        }

       

        private void Form1_Load(object sender, EventArgs e)
        {

           
        }

        private void RevCom_Click(object sender, EventArgs e)
        {
            MessageBox.Show("Select Unique Selectors file to reverse complement ");
            OpenFileDialog ofd1 = new OpenFileDialog();
            if (ofd1.ShowDialog() != DialogResult.OK) return;
            var output = (Path.Combine(Path.GetDirectoryName(ofd1.FileName), Path.GetFileNameWithoutExtension(ofd1.FileName) + "_withRevCom.txt")).OpenWrite();
            string[] lines = System.IO.File.ReadAllLines(ofd1.FileName);
            output.WriteLine("selectorSeq" + "\t" + "selectorLen" + "\t" + "SelectorChr" + "\t" + "selectorStart" + "\t" + "Left Arm" + "\t" + "LA_Tm " + "\t" + "Right Arm " + "\t" + "RA_Tm " + "\t" + "%GC" + "\t" + "G/C/A/T Len" + "\t" + "Left Dis." + "\t" + "Right Dis." + "\t" + "Poly Type" + "\t" + "ConcatRA_LA" + "\t" + "Reverse Complement");
            for (int i = 1; i < lines.Length ; i++)
            {
                string oneLine = lines[i];
                string[] lineItems = oneLine.Split('\t');
                string RA_and_LA=lineItems [6]+lineItems [4];
                DnaSequence revcom = new DnaSequence(RA_and_LA );
                revcom.RevComp();
                string selector = revcom.ToString();
                output.WriteLine(lineItems[0] + "\t" + lineItems[1] + "\t" + lineItems[2] + "\t" + lineItems[3] + "\t" + lineItems[4] + "\t" + lineItems[5] + "\t" + lineItems[6] + "\t" + lineItems[7] + "\t" + lineItems[8] + "\t" + lineItems[9] + "\t" + lineItems[10] + "\t" + lineItems[11] + "\t" + lineItems[12] + "\t" + RA_and_LA  + "\t" + selector );

            }
            output.Close();
            MessageBox.Show("Programme executed successfully.Name of the output file is : " +Path.GetFileNameWithoutExtension(ofd1.FileName) + "_withRevCom.txt");
            
              
 
        }

        private void mseIpoly_Click(object sender, EventArgs e)
        {
            histogram.Clear();
            RestrictionEnzyme MseI = RestrictionEnzymes.MseI;
            DnaSequence polyG = new DnaSequence("GGGGGGGGGG");
            DnaSequence polyC = new DnaSequence("CCCCCCCCCC");
            DnaSequence polyA = new DnaSequence("AAAAAAAAAA");
            DnaSequence polyT = new DnaSequence("TTTTTTTTTT");

            MessageBox.Show("Select the FASTA sequence files ");
            OpenFileDialog ofd = new OpenFileDialog();
            ofd.Multiselect = true;
            if (ofd.ShowDialog() != DialogResult.OK) return;
            MessageBox.Show("Select the location where you want to save your output file ");
            SaveFileDialog sfd = new SaveFileDialog();
            if (sfd.ShowDialog() != DialogResult.OK) return;
            var result = sfd.FileName.OpenWrite();
            char polyType = ' ';    // to get the type of poly repeats
            result.WriteLine("Sequence" + "\t" + "Seq length" + "\t" + "%GC" + "\t" + "G/C/A/T Length" + "\t" + "leftDistance" + "\t" + "rightDistance" + "\t" + "PolyType" + "\t" + "Chromosome Name" + "\t" + "Start Position in Chr");

            long totalLength = 0;
            int countFrags = 0;
            foreach (string fname in ofd.FileNames)
            {
                FastaFile ff = FastaFile.Load(fname);
                foreach (FastaRecord rec in ff.Records)
                {
                    List<int> MseISites = new List<int>();
                    totalLength += rec.Sequence.Count;
                    string ChrName = rec.HeaderLine; // assuming Chromosome name will be in the header line of the record


                    // Find all MseI sites
                    int offset = (int)rec.Sequence.Match(MseI.Sequence, 0);
                    do
                    {
                        MseISites.Add(offset);

                        offset = (int)rec.Sequence.Match(MseI.Sequence, offset + 1);

                    } while (offset > 0 && offset < rec.Sequence.Count);

                    // Find all polyG sites & write the corresponding MseI fragments
                    int m = 0;
                    offset = (int)rec.Sequence.Match(polyG, 0);

                    do
                    {
                        while (m < MseISites.Count && MseISites[m] < offset) m++;
                        if (m >= MseISites.Count) break;
                        polyType = 'G';
                        if (Report(result, rec.Sequence.SubSequence(MseISites[m - 1] + 1, MseISites[m] - MseISites[m - 1]), offset - MseISites[m - 1] - 1, polyType, ChrName, offset)) countFrags++;
                        //MessageBox.Show(offset.ToString());
                        offset = (int)rec.Sequence.Match(polyG, MseISites[m]);

                    } while (offset > 0 && offset < rec.Sequence.Count);

                    // Find all polyC sites & write the corresponding MseI fragments

                    m = 0;
                    offset = (int)rec.Sequence.Match(polyC, 0);
                    do
                    {
                        while (m < MseISites.Count && MseISites[m] < offset) m++;
                        if (m >= MseISites.Count) break;
                        polyType = 'C';
                        if (Report(result, rec.Sequence.SubSequence(MseISites[m - 1] + 1, MseISites[m] - MseISites[m - 1]), offset - MseISites[m - 1] - 1, polyType, ChrName, offset)) countFrags++;
                        offset = (int)rec.Sequence.Match(polyC, MseISites[m]);

                    } while (offset > 0 && offset < rec.Sequence.Count);

                    // Find all polyA sites & write the corresponding MseI fragments
                    m = 0;
                    offset = (int)rec.Sequence.Match(polyA, 0);
                    do
                    {
                        while (m < MseISites.Count && MseISites[m] < offset) m++;
                        if (m >= MseISites.Count) break;
                        polyType = 'A';
                        if (Report(result, rec.Sequence.SubSequence(MseISites[m - 1] + 1, MseISites[m] - MseISites[m - 1]), offset - MseISites[m - 1] - 1, polyType, ChrName, offset)) countFrags++;
                        offset = (int)rec.Sequence.Match(polyA, MseISites[m]);

                    } while (offset > 0 && offset < rec.Sequence.Count);

                    // Find all polyT sites & write the corresponding MseI fragments
                    m = 0;
                    offset = (int)rec.Sequence.Match(polyT, 0);
                    do
                    {
                        while (m < MseISites.Count && MseISites[m] < offset) m++;
                        if (m >= MseISites.Count) break;
                        polyType = 'T';
                        if (Report(result, rec.Sequence.SubSequence(MseISites[m - 1] + 1, MseISites[m] - MseISites[m - 1]), offset - MseISites[m - 1] - 1, polyType, ChrName, offset)) countFrags++;
                        offset = (int)rec.Sequence.Match(polyT, MseISites[m]);

                    } while (offset > 0 && offset < rec.Sequence.Count);

                }
                Console.WriteLine("Fragments: " + countFrags.ToString() + " length: " + (totalLength / 1e6).ToString() + " Mbp");
                ff = null;
            }
            foreach (var kvp in histogram)
            {
                Console.WriteLine(kvp.Key + "\t" + kvp.Value);
            }
            result.Close();
            MessageBox.Show("Programme executed successfully. Please click the next button to calculate the Tm.");
        }

        SortedDictionary<int, int> histogram = new SortedDictionary<int, int>();
        public bool Report(StreamWriter result, DnaSequence seq, int leftDistance, char polyType, string ChrName, int OFFSET)
        {
            if (seq.Count < 75 || seq.Count > 600) return false;
            int temp = leftDistance;
            byte nt = seq[temp];
            while (seq[temp] == nt) temp++;
            int gLength = temp - leftDistance;
            double perGC=seq.CountCases(IupacEncoding.GC) * 100 / seq.Count;
            if (gLength > 40) return false;
            if (!histogram.ContainsKey(gLength)) histogram[gLength] = 1;
            else histogram[gLength] = histogram[gLength] + 1;
            int rightDistance = (int)(seq.Count - leftDistance - gLength);
            if (leftDistance > 65 && rightDistance > 65) return false;
            if (leftDistance < 20 || rightDistance < 20) return false;
            if(perGC <30 || perGC >70) return false ;

            // Sequence Length GC GLength LeftFlank RightFlank
            result.WriteLine(seq.ToString() + "\t" + seq.Count + "\t" + perGC  + "\t" + gLength + "\t" + leftDistance + "\t" + rightDistance + "\t" + polyType + "\t" + ChrName + "\t" + (OFFSET - leftDistance + 1));
            return true;
        }

        
        private void ReadMe_Click(object sender, EventArgs e)
        {
            
            //MessageBox.Show(Directory.GetCurrentDirectory());  
            richTextBox1.Visible = true;
            richTextBox1.Text = "This is a programme to design unique poly repets in chromosome(s)";
            mseIpoly.Enabled = true;
            TmCalculation.Enabled = true;
            UnSelector.Enabled = true;
            RevCom.Enabled = true;
            richTextBox1.LoadFile(@"poly repeats redme.rtf");
            ReadMe.SendToBack();  
            CloseReadme.Location =new Point (39,27);
            CloseReadme.Visible = true;
            //CloseReadme.Enabled = true; 
  
            
        }

        private void CloseReadme_Click(object sender, EventArgs e)
        {
            richTextBox1.Visible = false;
            //CloseReadme.Enabled = false;
            CloseReadme.SendToBack();  
        }

        
         
        
    }
}
