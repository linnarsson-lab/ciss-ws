using System;
using System.Collections.Generic;
using System.Text;
using System.IO;
using System.Reflection;
using System.ComponentModel;
using System.Xml.Serialization;
using System.IO.Compression;

namespace Linnarsson.Utilities
{
	public class TabFileReader<T>
	{
		public static IEnumerable<T> Stream(string file, bool hasHeader, Func<string[],T> map)
		{
			var reader = file.OpenRead();
			using(reader)
			{
				if(hasHeader) reader.ReadLine();
				while(true)
				{
					string line = reader.ReadLine();
                    if (line == "") continue;
					if(line == null) yield break;
					yield return map(line.Split('\t'));
				}
			}
		}
	}

	/// <summary>
	/// Provides strongly typed access to a tab-delimited file, which must have a header row whose
	/// names match the properties of the target type exactly. Such files can be generated by the 
	/// <see cref="TabDelimitedFileWriter"/>. Properties marked with the XmlIgnore attribute are ignored.
	/// </summary>
	/// <typeparam name="T"></typeparam>
	public class TabDelimitedFileReader<T> where T: new()
	{
		private StreamReader reader;
		private Dictionary<string, int> headers;
		private bool IgnoreHeaders;

		public TabDelimitedFileReader(string path) : this(path, true, false) { }
		public TabDelimitedFileReader(string path, bool hasHeaders, bool ignoreHeaders)
		{
			reader = path.OpenRead();

			headers = new Dictionary<string, int>();
			if(hasHeaders)
			{
				string[] cols = reader.ReadLine().Split('\t');
				for(int ix = 0; ix < cols.Length; ix++)
				{
					headers[cols[ix]] = ix;
				}
			}
			IgnoreHeaders = ignoreHeaders;
		}

		public T Next()
		{
			string line = reader.ReadLine();
			if(line == null) return default(T);

			string[] record = line.Split('\t');
			T result = new T();

			int col = 0;
			foreach(PropertyInfo pi in typeof(T).GetProperties())
			{
				// Verify that the property has a setter and is not marked [XmlIgnore]
				if(pi.CanWrite && pi.GetCustomAttributes(typeof(XmlIgnoreAttribute), false).Length == 0)
				{
					if(!IgnoreHeaders)
					{
						if(headers.ContainsKey(pi.Name))
						{
							col = headers[pi.Name];
						}
						else
						{
							throw new IndexOutOfRangeException("File does not contain a column named " + pi.Name);
						}
					}
					object[] temp = pi.GetCustomAttributes(typeof(TypeConverterAttribute), false);
					if(temp.Length != 0)
					{
						TypeConverter tc = (TypeConverter)temp[0];
						pi.SetValue(result, tc.ConvertFromInvariantString(record[col]), null);
					}
					else
					{
						if(!TypeDescriptor.GetConverter(pi.PropertyType).IsValid(record[col]))
						{
							throw new ArgumentException("Illegal value: " + record[col], pi.Name);
						}
						pi.SetValue(result, TypeDescriptor.GetConverter(pi.PropertyType).ConvertFromInvariantString(record[col]), null);
					}
					col++;
				}
			}
			return result;
		}

		public void Close()
		{
			reader.Close();
		}

		public static List<T> ReadAll(string path)
		{
			return ReadAll(path, true, false);
		}

		public static List<T> ReadAll(string path, bool hasHeaders, bool ignoreHeaders)
		{
			TabDelimitedFileReader<T> rdr = new TabDelimitedFileReader<T>(path, hasHeaders, ignoreHeaders);
			List<T> result = new List<T>();
			while(true)
			{
				T item = rdr.Next();
				if(item != null) result.Add(item);
				else break;
			}
			rdr.Close();
			return result;
		}

		public static IEnumerable<T> Stream(string path, bool hasHeaders, bool ignoreHeaders)
		{
			TabDelimitedFileReader<T> reader = new TabDelimitedFileReader<T>(path, hasHeaders, ignoreHeaders);
			while(true)
			{
				T item = reader.Next();
				if(item == null) yield break;
				yield return item;
			}
		}
	}

	public class TabDelimitedFileWriter<T> where T : new()
	{
		StreamWriter writer;

		public TabDelimitedFileWriter(string path)
		{
			writer = new StreamWriter(path);

			// Write header row
			StringBuilder sb = new StringBuilder();
			foreach(PropertyInfo pi in typeof(T).GetProperties())
			{
				if(pi.CanWrite && pi.PropertyType.GetCustomAttributes(typeof(XmlIgnoreAttribute), false).Length == 0)
				{
					sb.Append(pi.Name);
					sb.Append("\t");
				}
			}
			sb.Length -= 1;
			writer.WriteLine(sb.ToString());
		}

		public void Append(T record)
		{
			StringBuilder sb = new StringBuilder();
			foreach(PropertyInfo pi in typeof(T).GetProperties())
			{
				if(pi.CanWrite)
				{
					sb.Append(TypeDescriptor.GetConverter(typeof(T)).ConvertToInvariantString(pi.GetValue(record,null)));
					sb.Append("\t");
				}
			}
			sb.Length -= 1;
			writer.WriteLine(sb.ToString());
		}

		public void Close()
		{
			writer.Close();
		}

		public static void WriteAll(string path, IList<T> list)
		{
			TabDelimitedFileWriter<T> tf = new TabDelimitedFileWriter<T>(path);
			foreach(T item in list)
			{
				tf.Append(item);
			}
			tf.Close();
		}
	}
}
